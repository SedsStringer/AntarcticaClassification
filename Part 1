//____________________LANDSAT 8 TOPOGRAPHIC CORRECTION & IMAGE EXPORTER____________________

/* AUTHOR: Chris Stringer (gycds@leeds.ac.uk)
   DESCRIPTION: This script takes Landsat 8 TOA (tier 2) images, applies a cloud mask and 
                topographically corrects the images. It also exports an NDSI image of the region
   BANDS USED: Red, Green, Blue, NIR, SWIR1, SWIR2 
   METHODS: 1) SETUP: Zooms to 'Area of Interest' and imports Landsat 8 TOA (tier 2) images 
            2) TOPOGRAPHIC CORRECTION: Topographically corrects images to reduce the impact of relief
               on any classifications.
               (adapted from: https://mygeoblog.com/2018/10/17/terrain-correction-in-gee/)
            3) IMAGES: Produces the images
            4) EXPORT: Exports the corrected image to Google Drive */                          
//____________________________________________________________________________________________________________________________________________________________________

//____________________1) SETUP____________________

// a) Set the extent of the analysis (e.g. coastline or bounding box) as the AOI (area of interest)

var AOI = ee.FeatureCollection('').geometry(); 

// b) Choose Landsat images

var l8 = ee.ImageCollection("LANDSAT/LC08/C01/T2_TOA"); // This is the repository that holds all Landsat 8, collection 1 (tier 2) TOA imagery - the most appropriate collection for Antarctica
var collection = l8.filterBounds(geometry)
var collection = collection.filter(ee.Filter.calendarRange(2018, 2020, 'year')) // This choosese images from 2018 to 2020, adjust to be appropraite for each site
                           .filter(ee.Filter.calendarRange(11, 4, 'month')) // This chooses images from the Austral Summer November (11) to April (4), adjust to be appropraite for each site
                           .sort('CLOUD_COVER', false) // Least cloudy images are placed at the top of the stack
                           .filterMetadata("CLOUD_COVER", "less_than" , 20) // Chooses images with less than 20% cloud cover
                           .filterMetadata("CLOUD_COVER", "greater_than" , 1); // Chooses images with greater than 1% cloud cover - a minimum threshold heloed remove images erroneously classed as 0%                       
Map.addLayer(collection);

// c) Cloud Mask (NB: "QA" = Quality Assessment. This is calcualted by Landsat and details are available in their documentations).

/* This script isn't perfect, and sometimes it is worth removing the aspects that deal with cirrus clouds as it isn't percet and 
    may hide too much of the image. Have a play around and test it out to make sure it meets your needs */

var getQABits = function(image, start, end, newName) {
// Compute the bits we need to extract.
var pattern = 0;
for (var i = start; i <= end; i++) {
  pattern += Math.pow(2, i);
}
// Return a single band image of the extracted QA bits, giving the band a new name.
return image.select([0], [newName])
              .bitwiseAnd(pattern)
              .rightShift(start);
};

// A function to mask out cloudy pixels.
var clouds = function(image) {
var QA = image.select(['BQA']);
return getQABits(QA, 4,4, 'Cloud').eq(0); // Get the internal_cloud_algorithm_flag bit and return an image masking out cloudy areas.
};

// A function to mask out pixels covered by cirrus clouds.

var cirrus = function(image) {
var QA = image.select(['BQA']);
return getQABits(QA, 11,12, 'cirrus').eq(1);
};

// A function to mask out remaining cloudy areas

var other = function(image) {
var QA = image.select(['BQA']);
return getQABits(QA, 5,6, 'other').eq(1);
};

var maskClouds = function(image) {
var c = clouds(image);
var ci = cirrus(image);
var o = other(image);
image = image.updateMask(ci);
image = image.updateMask(o);
return image.updateMask(c);
};

var collection = collection.map(maskClouds); // Maps the cloud mask over the image collection - soo all our selected images will be masked

var unmask = function(image) {
  return image.unmask(-0.99); // Sets a pixel value for these pixels, so they're usable when clustering.
};

// d) Import the REMA DEM

var dem_mask = REMA.clip(AOI.buffer(1000)); //CLIPS REMA TO THE COASTLINE + 1KM BUFFER 

// ____________________2) TOPOGRAPHIC CORRECTION____________________

// (adapted from: https://mygeoblog.com/2018/10/17/terrain-correction-in-gee/) - I refer you to this document for further info

var boxcar = ee.Kernel.square({   // Define a boxcar or low-pass kernel.
  radius: 3, units: 'pixels', normalize: true
});
var dem_mask = dem_mask.convolve(boxcar);

var scale = 30;
var degree2radian = 0.01745329;

// DEFINES CORRECTION FUNCTION

var terrainCorrection = function(collection) {

  collection = collection.map(illuminationCondition);
  collection = collection.map(illuminationCorrection);

  return(collection);

  function illuminationCondition(img){ // Function to calculate illumination condition (IC).

// Extract image metadata about solar position
  var SZ_rad = ee.Image.constant(ee.Number(ee.Number(90).subtract(img.get('SUN_ELEVATION'))).multiply(degree2radian)).clip(AOI.buffer(1000)); 
  var SA_rad = ee.Image.constant(ee.Number(img.get('SUN_AZIMUTH')).multiply(degree2radian)).clip(AOI.buffer(1000));  
  
// Creat terrain layers
  var slp = ee.Terrain.slope(dem_mask).clip(img.geometry().buffer(1000));
  var slp_rad = ee.Terrain.slope(dem_mask).multiply(degree2radian).clip(AOI.buffer(1000));
  var asp_rad = ee.Terrain.aspect(dem_mask).multiply(degree2radian).clip(AOI.buffer(1000));

// CALCULATE ILLUMINATION CONDITION

// slope part of the illumination condition
  var cosZ = SZ_rad.cos();
  var cosS = slp_rad.cos();
  var slope_illumination = cosS.expression("cosZ * cosS", 
                                          {'cosZ': cosZ,
                                          'cosS': cosS.select('slope')});
// aspect part of the illumination condition
  var sinZ = SZ_rad.sin(); 
  var sinS = slp_rad.sin();
  var cosAziDiff = (SA_rad.subtract(asp_rad)).cos();
  var aspect_illumination = sinZ.expression("sinZ * sinS * cosAziDiff", 
                                          {'sinZ': sinZ,
                                            'sinS': sinS,
                                            'cosAziDiff': cosAziDiff});
// full illumination condition (IC)
  var ic = slope_illumination.add(aspect_illumination);

// Add IC to original image
  var img_plus_ic = ee.Image(img.addBands(ic.rename('IC')).addBands(cosZ.rename('cosZ')).addBands(cosS.rename('cosS')).addBands(slp.rename('slope')));
  return img_plus_ic;
  }

// APPLY SUN-CANOPY-SENSORT + C CORRECTION METHOD TO IMAGES
 
  function illuminationCorrection(img){
    var props = img.toDictionary();
    var st = img.get('system:time_start');
    
    var img_plus_ic = img;
    var mask1 = img_plus_ic.select('nir').gt(-0.1);
    var mask2 = img_plus_ic.select('slope').gte(5)
                            .and(img_plus_ic.select('IC').gte(0))
                            .and(img_plus_ic.select('nir').gt(-0.1));
    var img_plus_ic_mask2 = ee.Image(img_plus_ic.updateMask(mask2));
    
// Specify Bands to topographically correct  
    var bandList = ['blue', 'green', 'red', 'nir', 'swir1', 'swir2']; 
    var compositeBands = img.bandNames();
    var nonCorrectBands = img.select(compositeBands.removeAll(bandList));
    
    var geom = ee.Geometry(img.get('system:footprint')).bounds().buffer(1000);
    
    function apply_SCSccorr(band){
      var method = 'SCSc';
      var out =  ee.Image(1).addBands(img_plus_ic_mask2.select('IC', band))
                            .reduceRegion({reducer: ee.Reducer.linearRegression(2,1),
                                          geometry: ee.Geometry(img.geometry()),
                                          scale: scale,
                                          bestEffort :true,
                                          tileScale: 16,
                                          maxPixels:1e12});

        var fit = out.combine({"coefficients": ee.Array([[1],[1]])}, false);

//Get the coefficients as a nested list,
// ast it to an array, and get just the selected column
                var out_a = (ee.Array(fit.get('coefficients')).get([0,0]));
                var out_b = (ee.Array(fit.get('coefficients')).get([1,0]));
                var out_c = out_a.divide(out_b);

// Apply the SCSc correction
        var SCSc_output = img_plus_ic_mask2.expression(
        "((image * (cosB * cosZ + cvalue)) / (ic + cvalue))", {
        'image': img_plus_ic_mask2.select(band),
        'ic': img_plus_ic_mask2.select('IC'),
        'cosB': img_plus_ic_mask2.select('cosS'),
        'cosZ': img_plus_ic_mask2.select('cosZ'),
        'cvalue': out_c
        });

      return SCSc_output;
    }

    var img_SCSccorr = ee.Image(bandList.map(apply_SCSccorr)).addBands(img_plus_ic.select('IC'));
    var bandList_IC = ee.List([bandList, 'IC']).flatten();
    img_SCSccorr = img_SCSccorr.unmask(img_plus_ic.select(bandList_IC)).select(bandList);

      img_SCSccorr = ee.Image(img_SCSccorr.addBands(nonCorrectBands).setMulti(props).set('system:time_start',st));
    return img_SCSccorr.select(['blue', 'green', 'red', 'nir', 'swir1', 'swir2']);  
  }
};  

//____________________3) IMAGES____________________

// a) Change the band names

var inBands = ee.List(['B1','B2','B3','B4','B5','B7', 'BQA']); // Landsat band names
var outBands = ee.List(['blue','green','red','nir','swir1','swir2', 'BQA']); // My names for each band

var collection =  collection.select(inBands, outBands); // These renames the Landsat band names into something more familiar

// b) Mosaic and correct the image

var img = ee.Image(collection.mosaic()); // Creates a single, mosaicked image of our collection
var original = img.clip(AOI.buffer(1000)); // Clips our image to the AOI + a 1km buffer
var correct = terrainCorrection(collection); // Runs the topographic correction over the entire image collection
var newimg = ee.Image(correct.qualityMosaic('blue')); // Creates a mosaic of all the corrected images
var corrected = newimg.clip(AOI.buffer(1000)); // Clips our image to the AOI + a 1km buffer

Map.addLayer(ee.Image(img),{ bands: 'red,green,blue',min: 0, max: 0.5},'original'); // adds original image mosaic to map

// NB: the topographic correction is a big function and takes a while to run - do not try to display this in GEE

//____________________4) EXPORT____________________

Export.image.toDrive({ // Exports the image to Google Drive
  image: corrected,
  description: 'DryVal-1988', // Name of file
  scale: 30,
  region: AOI.buffer(1000)
});


